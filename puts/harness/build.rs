use std::{
    env,
    path::{Path, PathBuf},
};

pub fn main() {
    println!("cargo:rerun-if-env-changed=VENDOR_DIR");
    println!("cargo:rerun-if-env-changed=WITH_PUT");
    println!("cargo:rerun-if-changed={}", env!("CARGO_MANIFEST_DIR"));

    let out_dir = env::var("OUT_DIR").unwrap();

    let bindings_path = PathBuf::from(&out_dir).join("bindings.rs");
    bindgen::Builder::default()
        .ctypes_prefix("::libc")
        .allowlist_file(".*/tlspuffin/[^/]+\\.h")
        .allowlist_recursively(false)
        .no_copy("^AGENT_DESCRIPTOR$")
        .parse_callbacks(Box::new(bindgen::CargoCallbacks::new()))
        .header("include/tlspuffin/put.h")
        .generate()
        .expect("Unable to generate Rust bindings for tlspuffin-harness-sys")
        .write_to_file(&bindings_path)
        .expect("Couldn't write bindings!");

    println!(
        "cargo:rustc-env=RUST_BINDINGS_FILE={}",
        bindings_path.to_string_lossy()
    );

    let src_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let inc_dir = src_dir.join("include");
    let dst_dir = PathBuf::from(out_dir);

    std::fs::create_dir_all(&inc_dir).unwrap();

    // NOTE cc automatically emits link flags for cargo
    //
    //     Alongside the rust bindings file generated by bindgen, this build
    //     script creates the `tlspuffin-harness-c` library containing the
    //     C-implemented part of the `tlspuffin-harness` library. This is
    //     specified through the `links` field in Cargo.toml.
    //
    //     It might be confusing that we never actually tell cargo where to find
    //     this native library. This is because the `cc` crate automatically
    //     emits these flags.
    //
    //     If we ever replace `cc`, we will need to manually emit the cargo
    //     metadata `cargo:rustc-link-lib` and `cargo:rustc-link-search`.
    cc::Build::new()
        .include(&inc_dir)
        .file("src/lib.c")
        .compile("tlspuffin-harness-c");

    println!("cargo:root={}", dst_dir.to_str().unwrap());
    println!("cargo:include={}", inc_dir.to_str().unwrap());

    let vendor_dir = PathBuf::from(
        env::var("VENDOR_DIR")
            .unwrap_or(concat!(env!("CARGO_MANIFEST_DIR"), "/../../vendor").to_string()),
    );

    let library_names = env::var("WITH_PUT")
        .map(|wp| wp.split(',').map(|s| s.to_string()).collect::<Vec<_>>())
        .unwrap_or_else(|_| {
            println!("cargo:rerun-if-changed={}", &vendor_dir.to_str().unwrap());
            all_libraries(&vendor_dir)
        });

    build_puts(&vendor_dir, library_names)
}

pub fn build_puts(vendor_dir: &Path, library_names: Vec<String>) {
    let protocols: Vec<&str> = vec![
        #[cfg(feature = "tls")]
        "tls",
    ];

    let src_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());

    let libraries: Vec<String> = library_names
        .iter()
        .map(|vendor| vendor_dir.join(vendor).to_str().unwrap().to_string())
        .collect();

    for vendor in libraries.iter() {
        println!("cargo:rerun-if-changed={}", vendor);
    }

    cmake::Config::new(src_dir)
        .profile("Debug")
        .define("BUILD_SHARED_LIBS", "OFF")
        .define("LIBRARIES", libraries.join(","))
        .define("PROTOCOLS", protocols.join(","))
        .build();

    println!(
        "cargo:rustc-link-search=native={}",
        out_dir.to_str().unwrap()
    );

    println!(
        "cargo:rustc-env=RUST_PUTS_INIT_FILE={}",
        out_dir.join("init.rs").to_str().unwrap()
    );
    println!("cargo:rustc-link-lib=static=puts-bundle");
}

pub fn all_libraries(vendor_dir: &Path) -> Vec<String> {
    if let Ok(dir_entry) = vendor_dir.read_dir() {
        dir_entry
            .filter_map(|x| x.ok())
            .map(|x| x.path())
            .filter(|x| x.is_dir())
            .map(|x| x.file_name().unwrap().to_str().unwrap().to_string())
            .collect()
    } else {
        vec![]
    }
}
