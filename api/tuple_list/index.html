<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Crate for macro-free variadic tuple metaprogramming."><meta name="keywords" content="rust, rustlang, rust-lang, tuple_list"><title>tuple_list - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script defer src="../crates.js"></script><script defer src="../main.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../tuple_list/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../tuple_list/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Crate tuple_list</a></h2><div class="sidebar-elems"><div class="block"><ul><li class="version">Version 0.1.3</li><li><a id="all-types" href="all.html">All Items</a></li></ul></div><section><div class="block"><ul><li><a href="#macros">Macros</a></li><li><a href="#traits">Traits</a></li></ul></div></section></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../tuple_list/index.html"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1">
                                <a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div>
                        </div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">tuple_list</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../src/tuple_list/lib.rs.html#1-834">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Crate for macro-free variadic tuple metaprogramming.</p>
<h2 id="rationale"><a href="#rationale">Rationale</a></h2>
<p>As of writing this crate, Rust does not support variadic generics
and does not allow to reason about tuples in general.</p>
<p>Most importantly, Rust does not allow one to generically
implement a trait for all tuples whose elements implement it.</p>
<p>This crate attempts to fill the gap by providing a way
to recursively define traits for tuples.</p>
<h2 id="tuple-lists"><a href="#tuple-lists">Tuple lists</a></h2>
<p>Tuple <code>(A, B, C, D)</code> can be unambiguously mapped into recursive tuple <code>(A, (B, (C, (D, ()))))</code>.</p>
<p>On each level it consists of a pair <code>(Head, Tail)</code>, where <code>Head</code> is tuple element and
<code>Tail</code> is a remainder of the list. For last element <code>Tail</code> is an empty list.</p>
<p>Unlike regular flat tuples, such recursive tuples can be effectively reasoned about in Rust.</p>
<p>This crate calls such structures “tuple lists” and provides a set of traits and macros
allowing one to conveniently work with them.</p>
<h2 id="example-1-plusone-recursive-trait"><a href="#example-1-plusone-recursive-trait">Example 1: <code>PlusOne</code> recursive trait</a></h2>
<p>Let’s create a trait which adds one to each element of a tuple list
of arbitrary length, behaving differently depending on element type.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// `TupleList` is a helper trait implemented by all tuple lists.</span>
<span class="comment">// Its use is optional, but it allows to avoid accidentally</span>
<span class="comment">// implementing traits for something other than tuple lists.</span>
<span class="kw">use</span> <span class="ident">tuple_list::TupleList</span>;
 
<span class="comment">// Define trait and implement it for several primitive types.</span>
<span class="kw">trait</span> <span class="ident">PlusOne</span> {
    <span class="kw">fn</span> <span class="ident">plus_one</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>);
}
<span class="kw">impl</span> <span class="ident">PlusOne</span> <span class="kw">for</span> <span class="ident">i32</span>    { <span class="kw">fn</span> <span class="ident">plus_one</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>) { <span class="kw-2">*</span><span class="self">self</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>; } }
<span class="kw">impl</span> <span class="ident">PlusOne</span> <span class="kw">for</span> <span class="ident">bool</span>   { <span class="kw">fn</span> <span class="ident">plus_one</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>) { <span class="kw-2">*</span><span class="self">self</span> <span class="op">=</span> <span class="op">!</span><span class="kw-2">*</span><span class="self">self</span>; } }
<span class="kw">impl</span> <span class="ident">PlusOne</span> <span class="kw">for</span> <span class="ident">String</span> { <span class="kw">fn</span> <span class="ident">plus_one</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>) { <span class="self">self</span>.<span class="ident">push</span>(<span class="string">&#39;1&#39;</span>); } }
 
<span class="comment">// Now we have to implement trait for an empty tuple,</span>
<span class="comment">// thus defining initial condition.</span>
<span class="kw">impl</span> <span class="ident">PlusOne</span> <span class="kw">for</span> () {
    <span class="kw">fn</span> <span class="ident">plus_one</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>) {}
}
 
<span class="comment">// Now we can implement trait for a non-empty tuple list,</span>
<span class="comment">// thus defining recursion and supporting tuple lists of arbitrary length.</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">Head</span>, <span class="ident">Tail</span><span class="op">&gt;</span> <span class="ident">PlusOne</span> <span class="kw">for</span> (<span class="ident">Head</span>, <span class="ident">Tail</span>) <span class="kw">where</span>
    <span class="ident">Head</span>: <span class="ident">PlusOne</span>,
    <span class="ident">Tail</span>: <span class="ident">PlusOne</span> <span class="op">+</span> <span class="ident">TupleList</span>,
{
    <span class="kw">fn</span> <span class="ident">plus_one</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>) {
        <span class="self">self</span>.<span class="number">0</span>.<span class="ident">plus_one</span>();
        <span class="self">self</span>.<span class="number">1</span>.<span class="ident">plus_one</span>();
    }
}
 
<span class="comment">// `tuple_list!` as a helper macro used to create</span>
<span class="comment">// tuple lists from a list of arguments.</span>
<span class="kw">use</span> <span class="ident">tuple_list::tuple_list</span>;
 
<span class="comment">// Now we can use our trait on tuple lists.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">tuple_list</span> <span class="op">=</span> <span class="macro">tuple_list!</span>(<span class="number">2</span>, <span class="bool-val">false</span>, <span class="ident">String::from</span>(<span class="string">&quot;abc&quot;</span>));
<span class="ident">tuple_list</span>.<span class="ident">plus_one</span>();
 
<span class="comment">// `tuple_list!` macro also allows us to unpack tuple lists</span>
<span class="kw">let</span> <span class="macro">tuple_list!</span>(<span class="ident">a</span>, <span class="ident">b</span>, <span class="ident">c</span>) <span class="op">=</span> <span class="ident">tuple_list</span>;
<span class="macro">assert_eq!</span>(<span class="ident">a</span>, <span class="number">3</span>);
<span class="macro">assert_eq!</span>(<span class="ident">b</span>, <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span><span class="ident">c</span>, <span class="string">&quot;abc1&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%2F%2F%20%60TupleList%60%20is%20a%20helper%20trait%20implemented%20by%20all%20tuple%20lists.%0A%2F%2F%20Its%20use%20is%20optional%2C%20but%20it%20allows%20to%20avoid%20accidentally%0A%2F%2F%20implementing%20traits%20for%20something%20other%20than%20tuple%20lists.%0Aextern%20crate%20r%23tuple_list%3B%0Afn%20main()%20%7B%0Ause%20tuple_list%3A%3ATupleList%3B%0A%20%0A%2F%2F%20Define%20trait%20and%20implement%20it%20for%20several%20primitive%20types.%0Atrait%20PlusOne%20%7B%0A%20%20%20%20fn%20plus_one(%26mut%20self)%3B%0A%7D%0Aimpl%20PlusOne%20for%20i32%20%20%20%20%7B%20fn%20plus_one(%26mut%20self)%20%7B%20*self%20%2B%3D%201%3B%20%7D%20%7D%0Aimpl%20PlusOne%20for%20bool%20%20%20%7B%20fn%20plus_one(%26mut%20self)%20%7B%20*self%20%3D%20!*self%3B%20%7D%20%7D%0Aimpl%20PlusOne%20for%20String%20%7B%20fn%20plus_one(%26mut%20self)%20%7B%20self.push('1')%3B%20%7D%20%7D%0A%20%0A%2F%2F%20Now%20we%20have%20to%20implement%20trait%20for%20an%20empty%20tuple%2C%0A%2F%2F%20thus%20defining%20initial%20condition.%0Aimpl%20PlusOne%20for%20()%20%7B%0A%20%20%20%20fn%20plus_one(%26mut%20self)%20%7B%7D%0A%7D%0A%20%0A%2F%2F%20Now%20we%20can%20implement%20trait%20for%20a%20non-empty%20tuple%20list%2C%0A%2F%2F%20thus%20defining%20recursion%20and%20supporting%20tuple%20lists%20of%20arbitrary%20length.%0Aimpl%3CHead%2C%20Tail%3E%20PlusOne%20for%20(Head%2C%20Tail)%20where%0A%20%20%20%20Head%3A%20PlusOne%2C%0A%20%20%20%20Tail%3A%20PlusOne%20%2B%20TupleList%2C%0A%7B%0A%20%20%20%20fn%20plus_one(%26mut%20self)%20%7B%0A%20%20%20%20%20%20%20%20self.0.plus_one()%3B%0A%20%20%20%20%20%20%20%20self.1.plus_one()%3B%0A%20%20%20%20%7D%0A%7D%0A%20%0A%2F%2F%20%60tuple_list!%60%20as%20a%20helper%20macro%20used%20to%20create%0A%2F%2F%20tuple%20lists%20from%20a%20list%20of%20arguments.%0Ause%20tuple_list%3A%3Atuple_list%3B%0A%20%0A%2F%2F%20Now%20we%20can%20use%20our%20trait%20on%20tuple%20lists.%0Alet%20mut%20tuple_list%20%3D%20tuple_list!(2%2C%20false%2C%20String%3A%3Afrom(%22abc%22))%3B%0Atuple_list.plus_one()%3B%0A%20%0A%2F%2F%20%60tuple_list!%60%20macro%20also%20allows%20us%20to%20unpack%20tuple%20lists%0Alet%20tuple_list!(a%2C%20b%2C%20c)%20%3D%20tuple_list%3B%0Aassert_eq!(a%2C%203)%3B%0Aassert_eq!(b%2C%20true)%3B%0Aassert_eq!(%26c%2C%20%22abc1%22)%3B%0A%7D&amp;edition=2018">Run</a></div>
<h2 id="example-2-customdisplay-recursive-trait"><a href="#example-2-customdisplay-recursive-trait">Example 2: <code>CustomDisplay</code> recursive trait</a></h2>
<p>Let’s create a simple <code>Display</code>-like trait implemented for all tuples
lists whose elements implement it.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Define the trait and implement it for several standard types.</span>
<span class="kw">trait</span> <span class="ident">CustomDisplay</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">String</span>;
}
<span class="kw">impl</span> <span class="ident">CustomDisplay</span> <span class="kw">for</span> <span class="ident">i32</span>  { <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">String</span> { <span class="self">self</span>.<span class="ident">to_string</span>() } }
<span class="kw">impl</span> <span class="ident">CustomDisplay</span> <span class="kw">for</span> <span class="ident">bool</span> { <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">String</span> { <span class="self">self</span>.<span class="ident">to_string</span>() } }
<span class="kw">impl</span> <span class="ident">CustomDisplay</span> <span class="kw">for</span> <span class="kw-2">&amp;</span><span class="ident">str</span> { <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">String</span> { <span class="self">self</span>.<span class="ident">to_string</span>() } }
 
<span class="comment">// Now we have to implement trait for an empty tuple,</span>
<span class="comment">// thus defining initial condition.</span>
<span class="kw">impl</span> <span class="ident">CustomDisplay</span> <span class="kw">for</span> () {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">String</span> { <span class="ident">String::from</span>(<span class="string">&quot;&lt;empty&gt;&quot;</span>) }
}
 
<span class="comment">// In order to avoid having trailing spaces, we need</span>
<span class="comment">// custom logic for tuple lists of exactly one element.</span>
<span class="comment">//</span>
<span class="comment">// The simplest way is to use `TupleList::TUPLE_LIST_SIZE`</span>
<span class="comment">// associated constant, but there is also another option.</span>
<span class="comment">//</span>
<span class="comment">// Instead of defining initial condition for empty tuple list</span>
<span class="comment">// and recursion for non-empty ones, we can define *two*</span>
<span class="comment">// initial conditions: one for an empty tuple list and</span>
<span class="comment">// one for tuple lists of exactly one element.</span>
<span class="comment">// Then we can define recursion for tuple lists of two or more elements.</span>
<span class="comment">//</span>
<span class="comment">// Here we define second initial condition for tuple list</span>
<span class="comment">// of exactly one element.</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">Head</span><span class="op">&gt;</span> <span class="ident">CustomDisplay</span> <span class="kw">for</span> (<span class="ident">Head</span>, ()) <span class="kw">where</span>
    <span class="ident">Head</span>: <span class="ident">CustomDisplay</span>,
{
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">String</span> {
        <span class="kw">return</span> <span class="self">self</span>.<span class="number">0</span>.<span class="ident">fmt</span>()
    }
}
 
<span class="comment">// Recursion step is defined for all tuple lists</span>
<span class="comment">// longer than one element.</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">Head</span>, <span class="ident">Next</span>, <span class="ident">Tail</span><span class="op">&gt;</span> <span class="ident">CustomDisplay</span> <span class="kw">for</span> (<span class="ident">Head</span>, (<span class="ident">Next</span>, <span class="ident">Tail</span>)) <span class="kw">where</span>
    <span class="ident">Head</span>: <span class="ident">CustomDisplay</span>,
    (<span class="ident">Next</span>, <span class="ident">Tail</span>): <span class="ident">CustomDisplay</span> <span class="op">+</span> <span class="ident">TupleList</span>,
    <span class="ident">Tail</span>: <span class="ident">TupleList</span>,
{
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">String</span> {
        <span class="kw">return</span> <span class="macro">format!</span>(<span class="string">&quot;{} {}&quot;</span>, <span class="self">self</span>.<span class="number">0</span>.<span class="ident">fmt</span>(), <span class="self">self</span>.<span class="number">1</span>.<span class="ident">fmt</span>());
    }
}
 
<span class="comment">// Ensure `fmt` is called for each element.</span>
<span class="kw">let</span> <span class="ident">tuple_list</span> <span class="op">=</span> <span class="macro">tuple_list!</span>(<span class="number">2</span>, <span class="bool-val">false</span>, <span class="string">&quot;abc&quot;</span>);
<span class="macro">assert_eq!</span>(
    <span class="ident">tuple_list</span>.<span class="ident">fmt</span>(),
    <span class="string">&quot;2 false abc&quot;</span>,
);
 
<span class="comment">// Since tuple lists implement `CustomDisplay` themselves, they can</span>
<span class="comment">// be elements in other tuple lists implementing `CustomDisplay`.</span>
<span class="kw">let</span> <span class="ident">nested_tuple_list</span> <span class="op">=</span> <span class="macro">tuple_list!</span>(<span class="number">2</span>, <span class="bool-val">false</span>, <span class="string">&quot;abc&quot;</span>, <span class="macro">tuple_list!</span>(<span class="number">3</span>, <span class="bool-val">true</span>, <span class="string">&quot;def&quot;</span>));
<span class="macro">assert_eq!</span>(
    <span class="ident">nested_tuple_list</span>.<span class="ident">fmt</span>(),
    <span class="string">&quot;2 false abc 3 true def&quot;</span>,
);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Aextern%20crate%20r%23tuple_list%3B%0Afn%20main()%20%7B%0Ause%20tuple_list%3A%3ATupleList%3B%0Ause%20tuple_list%3A%3Atuple_list%3B%0A%2F%2F%20Define%20the%20trait%20and%20implement%20it%20for%20several%20standard%20types.%0Atrait%20CustomDisplay%20%7B%0A%20%20%20%20fn%20fmt(%26self)%20-%3E%20String%3B%0A%7D%0Aimpl%20CustomDisplay%20for%20i32%20%20%7B%20fn%20fmt(%26self)%20-%3E%20String%20%7B%20self.to_string()%20%7D%20%7D%0Aimpl%20CustomDisplay%20for%20bool%20%7B%20fn%20fmt(%26self)%20-%3E%20String%20%7B%20self.to_string()%20%7D%20%7D%0Aimpl%20CustomDisplay%20for%20%26str%20%7B%20fn%20fmt(%26self)%20-%3E%20String%20%7B%20self.to_string()%20%7D%20%7D%0A%20%0A%2F%2F%20Now%20we%20have%20to%20implement%20trait%20for%20an%20empty%20tuple%2C%0A%2F%2F%20thus%20defining%20initial%20condition.%0Aimpl%20CustomDisplay%20for%20()%20%7B%0A%20%20%20%20fn%20fmt(%26self)%20-%3E%20String%20%7B%20String%3A%3Afrom(%22%3Cempty%3E%22)%20%7D%0A%7D%0A%20%0A%2F%2F%20In%20order%20to%20avoid%20having%20trailing%20spaces%2C%20we%20need%0A%2F%2F%20custom%20logic%20for%20tuple%20lists%20of%20exactly%20one%20element.%0A%2F%2F%0A%2F%2F%20The%20simplest%20way%20is%20to%20use%20%60TupleList%3A%3ATUPLE_LIST_SIZE%60%0A%2F%2F%20associated%20constant%2C%20but%20there%20is%20also%20another%20option.%0A%2F%2F%0A%2F%2F%20Instead%20of%20defining%20initial%20condition%20for%20empty%20tuple%20list%0A%2F%2F%20and%20recursion%20for%20non-empty%20ones%2C%20we%20can%20define%20*two*%0A%2F%2F%20initial%20conditions%3A%20one%20for%20an%20empty%20tuple%20list%20and%0A%2F%2F%20one%20for%20tuple%20lists%20of%20exactly%20one%20element.%0A%2F%2F%20Then%20we%20can%20define%20recursion%20for%20tuple%20lists%20of%20two%20or%20more%20elements.%0A%2F%2F%0A%2F%2F%20Here%20we%20define%20second%20initial%20condition%20for%20tuple%20list%0A%2F%2F%20of%20exactly%20one%20element.%0Aimpl%3CHead%3E%20CustomDisplay%20for%20(Head%2C%20())%20where%0A%20%20%20%20Head%3A%20CustomDisplay%2C%0A%7B%0A%20%20%20%20fn%20fmt(%26self)%20-%3E%20String%20%7B%0A%20%20%20%20%20%20%20%20return%20self.0.fmt()%0A%20%20%20%20%7D%0A%7D%0A%20%0A%2F%2F%20Recursion%20step%20is%20defined%20for%20all%20tuple%20lists%0A%2F%2F%20longer%20than%20one%20element.%0Aimpl%3CHead%2C%20Next%2C%20Tail%3E%20CustomDisplay%20for%20(Head%2C%20(Next%2C%20Tail))%20where%0A%20%20%20%20Head%3A%20CustomDisplay%2C%0A%20%20%20%20(Next%2C%20Tail)%3A%20CustomDisplay%20%2B%20TupleList%2C%0A%20%20%20%20Tail%3A%20TupleList%2C%0A%7B%0A%20%20%20%20fn%20fmt(%26self)%20-%3E%20String%20%7B%0A%20%20%20%20%20%20%20%20return%20format!(%22%7B%7D%20%7B%7D%22%2C%20self.0.fmt()%2C%20self.1.fmt())%3B%0A%20%20%20%20%7D%0A%7D%0A%20%0A%2F%2F%20Ensure%20%60fmt%60%20is%20called%20for%20each%20element.%0Alet%20tuple_list%20%3D%20tuple_list!(2%2C%20false%2C%20%22abc%22)%3B%0Aassert_eq!(%0A%20%20%20%20tuple_list.fmt()%2C%0A%20%20%20%20%222%20false%20abc%22%2C%0A)%3B%0A%20%0A%2F%2F%20Since%20tuple%20lists%20implement%20%60CustomDisplay%60%20themselves%2C%20they%20can%0A%2F%2F%20be%20elements%20in%20other%20tuple%20lists%20implementing%20%60CustomDisplay%60.%0Alet%20nested_tuple_list%20%3D%20tuple_list!(2%2C%20false%2C%20%22abc%22%2C%20tuple_list!(3%2C%20true%2C%20%22def%22))%3B%0Aassert_eq!(%0A%20%20%20%20nested_tuple_list.fmt()%2C%0A%20%20%20%20%222%20false%20abc%203%20true%20def%22%2C%0A)%3B%0A%7D&amp;edition=2018">Run</a></div>
<h2 id="example-3-swapstringandint-recursive-trait"><a href="#example-3-swapstringandint-recursive-trait">Example 3: <code>SwapStringAndInt</code> recursive trait</a></h2>
<p>Let’s implement a trait which converts <code>i32</code> to <code>String</code> and vice versa.</p>
<p>This example is way more complex that the other
because it maps one tuple list into another tuple list.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Let&#39;s define and implement a trait for `i32` and `String`</span>
<span class="comment">// so that it converts `String` to `i32` and vice versa.</span>
<span class="kw">trait</span> <span class="ident">SwapStringAndInt</span> {
    <span class="kw">type</span> <span class="ident">Other</span>;
    <span class="kw">fn</span> <span class="ident">swap</span>(<span class="self">self</span>) -&gt; <span class="ident"><span class="self">Self</span>::Other</span>;
}
<span class="kw">impl</span> <span class="ident">SwapStringAndInt</span> <span class="kw">for</span> <span class="ident">i32</span> {
    <span class="kw">type</span> <span class="ident">Other</span> <span class="op">=</span> <span class="ident">String</span>;
    <span class="kw">fn</span> <span class="ident">swap</span>(<span class="self">self</span>) -&gt; <span class="ident">String</span> { <span class="self">self</span>.<span class="ident">to_string</span>() }
}
<span class="kw">impl</span> <span class="ident">SwapStringAndInt</span> <span class="kw">for</span> <span class="ident">String</span> {
    <span class="kw">type</span> <span class="ident">Other</span> <span class="op">=</span> <span class="ident">i32</span>;
    <span class="kw">fn</span> <span class="ident">swap</span>(<span class="self">self</span>) -&gt; <span class="ident">i32</span> { <span class="self">self</span>.<span class="ident">parse</span>().<span class="ident">unwrap</span>() }
}
 
<span class="comment">// Now we have to implement trait for an empty tuple,</span>
<span class="comment">// thus defining initial condition.</span>
<span class="kw">impl</span> <span class="ident">SwapStringAndInt</span> <span class="kw">for</span> () {
    <span class="kw">type</span> <span class="ident">Other</span> <span class="op">=</span> ();
    <span class="kw">fn</span> <span class="ident">swap</span>(<span class="self">self</span>) -&gt; () { () }
}
 
<span class="comment">// Now we can implement trait for a non-empty tuple list,</span>
<span class="comment">// thus defining recursion and supporting tuple lists of arbitrary length.</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">Head</span>, <span class="ident">Tail</span>, <span class="ident">TailOther</span><span class="op">&gt;</span> <span class="ident">SwapStringAndInt</span> <span class="kw">for</span> (<span class="ident">Head</span>, <span class="ident">Tail</span>) <span class="kw">where</span>
    <span class="ident">Head</span>: <span class="ident">SwapStringAndInt</span>,
    <span class="ident">Tail</span>: <span class="ident">SwapStringAndInt</span><span class="op">&lt;</span><span class="ident">Other</span><span class="op">=</span><span class="ident">TailOther</span><span class="op">&gt;</span> <span class="op">+</span> <span class="ident">TupleList</span>,
    <span class="ident">TailOther</span>: <span class="ident">TupleList</span>,
{
    <span class="kw">type</span> <span class="ident">Other</span> <span class="op">=</span> (<span class="ident">Head::Other</span>, <span class="ident">Tail::Other</span>);
    <span class="kw">fn</span> <span class="ident">swap</span>(<span class="self">self</span>) -&gt; <span class="ident"><span class="self">Self</span>::Other</span> {
        (<span class="self">self</span>.<span class="number">0</span>.<span class="ident">swap</span>(), <span class="self">self</span>.<span class="number">1</span>.<span class="ident">swap</span>())
    }
}
 
<span class="comment">// Tuple lists implement `SwapStringAndInt` by calling `SwapStringAndInt::swap`</span>
<span class="comment">// on each member and returning tuple list of resulting values.</span>
<span class="kw">let</span> <span class="ident">original</span> <span class="op">=</span> <span class="macro">tuple_list!</span>(<span class="number">4</span>, <span class="ident">String::from</span>(<span class="string">&quot;2&quot;</span>), <span class="number">7</span>, <span class="ident">String::from</span>(<span class="string">&quot;13&quot;</span>));
<span class="kw">let</span> <span class="ident">swapped</span>  <span class="op">=</span> <span class="macro">tuple_list!</span>(<span class="ident">String::from</span>(<span class="string">&quot;4&quot;</span>), <span class="number">2</span>, <span class="ident">String::from</span>(<span class="string">&quot;7&quot;</span>), <span class="number">13</span>);
 
<span class="macro">assert_eq!</span>(<span class="ident">original</span>.<span class="ident">swap</span>(), <span class="ident">swapped</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Aextern%20crate%20r%23tuple_list%3B%0Afn%20main()%20%7B%0Ause%20tuple_list%3A%3ATupleList%3B%0Ause%20tuple_list%3A%3Atuple_list%3B%0A%2F%2F%20Let's%20define%20and%20implement%20a%20trait%20for%20%60i32%60%20and%20%60String%60%0A%2F%2F%20so%20that%20it%20converts%20%60String%60%20to%20%60i32%60%20and%20vice%20versa.%0Atrait%20SwapStringAndInt%20%7B%0A%20%20%20%20type%20Other%3B%0A%20%20%20%20fn%20swap(self)%20-%3E%20Self%3A%3AOther%3B%0A%7D%0Aimpl%20SwapStringAndInt%20for%20i32%20%7B%0A%20%20%20%20type%20Other%20%3D%20String%3B%0A%20%20%20%20fn%20swap(self)%20-%3E%20String%20%7B%20self.to_string()%20%7D%0A%7D%0Aimpl%20SwapStringAndInt%20for%20String%20%7B%0A%20%20%20%20type%20Other%20%3D%20i32%3B%0A%20%20%20%20fn%20swap(self)%20-%3E%20i32%20%7B%20self.parse().unwrap()%20%7D%0A%7D%0A%20%0A%2F%2F%20Now%20we%20have%20to%20implement%20trait%20for%20an%20empty%20tuple%2C%0A%2F%2F%20thus%20defining%20initial%20condition.%0Aimpl%20SwapStringAndInt%20for%20()%20%7B%0A%20%20%20%20type%20Other%20%3D%20()%3B%0A%20%20%20%20fn%20swap(self)%20-%3E%20()%20%7B%20()%20%7D%0A%7D%0A%20%0A%2F%2F%20Now%20we%20can%20implement%20trait%20for%20a%20non-empty%20tuple%20list%2C%0A%2F%2F%20thus%20defining%20recursion%20and%20supporting%20tuple%20lists%20of%20arbitrary%20length.%0Aimpl%3CHead%2C%20Tail%2C%20TailOther%3E%20SwapStringAndInt%20for%20(Head%2C%20Tail)%20where%0A%20%20%20%20Head%3A%20SwapStringAndInt%2C%0A%20%20%20%20Tail%3A%20SwapStringAndInt%3COther%3DTailOther%3E%20%2B%20TupleList%2C%0A%20%20%20%20TailOther%3A%20TupleList%2C%0A%7B%0A%20%20%20%20type%20Other%20%3D%20(Head%3A%3AOther%2C%20Tail%3A%3AOther)%3B%0A%20%20%20%20fn%20swap(self)%20-%3E%20Self%3A%3AOther%20%7B%0A%20%20%20%20%20%20%20%20(self.0.swap()%2C%20self.1.swap())%0A%20%20%20%20%7D%0A%7D%0A%20%0A%2F%2F%20Tuple%20lists%20implement%20%60SwapStringAndInt%60%20by%20calling%20%60SwapStringAndInt%3A%3Aswap%60%0A%2F%2F%20on%20each%20member%20and%20returning%20tuple%20list%20of%20resulting%20values.%0Alet%20original%20%3D%20tuple_list!(4%2C%20String%3A%3Afrom(%222%22)%2C%207%2C%20String%3A%3Afrom(%2213%22))%3B%0Alet%20swapped%20%20%3D%20tuple_list!(String%3A%3Afrom(%224%22)%2C%202%2C%20String%3A%3Afrom(%227%22)%2C%2013)%3B%0A%20%0Aassert_eq!(original.swap()%2C%20swapped)%3B%0A%7D&amp;edition=2018">Run</a></div>
<h2 id="example-4-prepend-and-append-functions"><a href="#example-4-prepend-and-append-functions">Example 4: prepend and append functions</a></h2>
<p>Let’s implement append and prepend functions for tuple lists.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Prepend is a trivial operation for tuple lists.</span>
<span class="comment">// We just create a new pair from prepended element</span>
<span class="comment">// and the remainder of the list.</span>
<span class="kw">fn</span> <span class="ident">prepend</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">Tail</span>: <span class="ident">TupleList</span><span class="op">&gt;</span>(<span class="ident">value</span>: <span class="ident">T</span>, <span class="ident">tail</span>: <span class="ident">Tail</span>) -&gt; (<span class="ident">T</span>, <span class="ident">Tail</span>) {
    (<span class="ident">value</span>, <span class="ident">tail</span>)
}
 
<span class="comment">// Append is a bit more comples. We&#39;ll need a trait for that.</span>
<span class="kw">trait</span> <span class="ident">Append</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>: <span class="ident">TupleList</span> {
    <span class="kw">type</span> <span class="ident">AppendResult</span>: <span class="ident">TupleList</span>;
 
    <span class="kw">fn</span> <span class="ident">append</span>(<span class="self">self</span>, <span class="ident">value</span>: <span class="ident">T</span>) -&gt; <span class="ident"><span class="self">Self</span>::AppendResult</span>;
}
 
<span class="comment">// Implement append for an empty tuple list.</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">Append</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="kw">for</span> () {
    <span class="kw">type</span> <span class="ident">AppendResult</span> <span class="op">=</span> (<span class="ident">T</span>, ());
 
    <span class="comment">// Append for an empty tuple list is quite trivial.</span>
    <span class="kw">fn</span> <span class="ident">append</span>(<span class="self">self</span>, <span class="ident">value</span>: <span class="ident">T</span>) -&gt; <span class="ident"><span class="self">Self</span>::AppendResult</span> { (<span class="ident">value</span>, ()) }
}
 
<span class="comment">// Implement append for non-empty tuple list.</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">Head</span>, <span class="ident">Tail</span>, <span class="ident">T</span><span class="op">&gt;</span> <span class="ident">Append</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="kw">for</span> (<span class="ident">Head</span>, <span class="ident">Tail</span>) <span class="kw">where</span>
    <span class="self">Self</span>: <span class="ident">TupleList</span>,
    <span class="ident">Tail</span>: <span class="ident">Append</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
    (<span class="ident">Head</span>, <span class="ident">Tail::AppendResult</span>): <span class="ident">TupleList</span>,
{
    <span class="kw">type</span> <span class="ident">AppendResult</span> <span class="op">=</span> (<span class="ident">Head</span>, <span class="ident">Tail::AppendResult</span>);
 
    <span class="comment">// Here we deconstruct tuple list,</span>
    <span class="comment">// recursively call append on the</span>
    <span class="comment">// tail of it, and then reconstruct</span>
    <span class="comment">// the list using the new tail.</span>
    <span class="kw">fn</span> <span class="ident">append</span>(<span class="self">self</span>, <span class="ident">value</span>: <span class="ident">T</span>) -&gt; <span class="ident"><span class="self">Self</span>::AppendResult</span> {
        <span class="kw">let</span> (<span class="ident">head</span>, <span class="ident">tail</span>) <span class="op">=</span> <span class="self">self</span>;
        <span class="kw">return</span> (<span class="ident">head</span>, <span class="ident">tail</span>.<span class="ident">append</span>(<span class="ident">value</span>));
    }
}
 
<span class="comment">// Now we can use our append and prepend functions</span>
<span class="comment">// on tuple lists.</span>
<span class="kw">let</span> <span class="ident">original</span>  <span class="op">=</span> <span class="macro">tuple_list!</span>(   <span class="number">1</span>, <span class="string">&quot;foo&quot;</span>, <span class="bool-val">false</span>);
<span class="kw">let</span> <span class="ident">appended</span>  <span class="op">=</span> <span class="macro">tuple_list!</span>(   <span class="number">1</span>, <span class="string">&quot;foo&quot;</span>, <span class="bool-val">false</span>, <span class="number">5</span>);
<span class="kw">let</span> <span class="ident">prepended</span> <span class="op">=</span> <span class="macro">tuple_list!</span>(<span class="number">5</span>, <span class="number">1</span>, <span class="string">&quot;foo&quot;</span>, <span class="bool-val">false</span>);
 
<span class="macro">assert_eq!</span>(<span class="ident">original</span>.<span class="ident">append</span>(<span class="number">5</span>), <span class="ident">appended</span>);
<span class="macro">assert_eq!</span>(<span class="ident">prepend</span>(<span class="number">5</span>, <span class="ident">original</span>), <span class="ident">prepended</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Aextern%20crate%20r%23tuple_list%3B%0Afn%20main()%20%7B%0Ause%20tuple_list%3A%3ATupleList%3B%0Ause%20tuple_list%3A%3Atuple_list%3B%0A%2F%2F%20Prepend%20is%20a%20trivial%20operation%20for%20tuple%20lists.%0A%2F%2F%20We%20just%20create%20a%20new%20pair%20from%20prepended%20element%0A%2F%2F%20and%20the%20remainder%20of%20the%20list.%0Afn%20prepend%3CT%2C%20Tail%3A%20TupleList%3E(value%3A%20T%2C%20tail%3A%20Tail)%20-%3E%20(T%2C%20Tail)%20%7B%0A%20%20%20%20(value%2C%20tail)%0A%7D%0A%20%0A%2F%2F%20Append%20is%20a%20bit%20more%20comples.%20We'll%20need%20a%20trait%20for%20that.%0Atrait%20Append%3CT%3E%3A%20TupleList%20%7B%0A%20%20%20%20type%20AppendResult%3A%20TupleList%3B%0A%20%0A%20%20%20%20fn%20append(self%2C%20value%3A%20T)%20-%3E%20Self%3A%3AAppendResult%3B%0A%7D%0A%20%0A%2F%2F%20Implement%20append%20for%20an%20empty%20tuple%20list.%0Aimpl%3CT%3E%20Append%3CT%3E%20for%20()%20%7B%0A%20%20%20%20type%20AppendResult%20%3D%20(T%2C%20())%3B%0A%20%0A%20%20%20%20%2F%2F%20Append%20for%20an%20empty%20tuple%20list%20is%20quite%20trivial.%0A%20%20%20%20fn%20append(self%2C%20value%3A%20T)%20-%3E%20Self%3A%3AAppendResult%20%7B%20(value%2C%20())%20%7D%0A%7D%0A%20%0A%2F%2F%20Implement%20append%20for%20non-empty%20tuple%20list.%0Aimpl%3CHead%2C%20Tail%2C%20T%3E%20Append%3CT%3E%20for%20(Head%2C%20Tail)%20where%0A%20%20%20%20Self%3A%20TupleList%2C%0A%20%20%20%20Tail%3A%20Append%3CT%3E%2C%0A%20%20%20%20(Head%2C%20Tail%3A%3AAppendResult)%3A%20TupleList%2C%0A%7B%0A%20%20%20%20type%20AppendResult%20%3D%20(Head%2C%20Tail%3A%3AAppendResult)%3B%0A%20%0A%20%20%20%20%2F%2F%20Here%20we%20deconstruct%20tuple%20list%2C%0A%20%20%20%20%2F%2F%20recursively%20call%20append%20on%20the%0A%20%20%20%20%2F%2F%20tail%20of%20it%2C%20and%20then%20reconstruct%0A%20%20%20%20%2F%2F%20the%20list%20using%20the%20new%20tail.%0A%20%20%20%20fn%20append(self%2C%20value%3A%20T)%20-%3E%20Self%3A%3AAppendResult%20%7B%0A%20%20%20%20%20%20%20%20let%20(head%2C%20tail)%20%3D%20self%3B%0A%20%20%20%20%20%20%20%20return%20(head%2C%20tail.append(value))%3B%0A%20%20%20%20%7D%0A%7D%0A%20%0A%2F%2F%20Now%20we%20can%20use%20our%20append%20and%20prepend%20functions%0A%2F%2F%20on%20tuple%20lists.%0Alet%20original%20%20%3D%20tuple_list!(%20%20%201%2C%20%22foo%22%2C%20false)%3B%0Alet%20appended%20%20%3D%20tuple_list!(%20%20%201%2C%20%22foo%22%2C%20false%2C%205)%3B%0Alet%20prepended%20%3D%20tuple_list!(5%2C%201%2C%20%22foo%22%2C%20false)%3B%0A%20%0Aassert_eq!(original.append(5)%2C%20appended)%3B%0Aassert_eq!(prepend(5%2C%20original)%2C%20prepended)%3B%0A%7D&amp;edition=2018">Run</a></div>
<h2 id="example-5-reverse-function"><a href="#example-5-reverse-function">Example 5: reverse function</a></h2>
<p>We can also implement a function which reverses elements of a tuple list.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Rewind is a helper trait which maintains two tuple lists:</span>
<span class="comment">// `Todo` (which is `Self` for the trait) is the remainder of a tuple list to be reversed.</span>
<span class="comment">// `Done` is already reversed part of it.</span>
<span class="kw">trait</span> <span class="ident">Rewind</span><span class="op">&lt;</span><span class="ident">Done</span>: <span class="ident">TupleList</span><span class="op">&gt;</span> {
    <span class="comment">// RewindResult is the type of fully reversed tuple.</span>
    <span class="kw">type</span> <span class="ident">RewindResult</span>: <span class="ident">TupleList</span>;
 
    <span class="kw">fn</span> <span class="ident">rewind</span>(<span class="self">self</span>, <span class="ident">done</span>: <span class="ident">Done</span>) -&gt; <span class="ident"><span class="self">Self</span>::RewindResult</span>;
}
 
<span class="comment">// Initial condition.</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">Done</span>: <span class="ident">TupleList</span><span class="op">&gt;</span> <span class="ident">Rewind</span><span class="op">&lt;</span><span class="ident">Done</span><span class="op">&gt;</span> <span class="kw">for</span> () {
    <span class="kw">type</span> <span class="ident">RewindResult</span> <span class="op">=</span> <span class="ident">Done</span>;
 
    <span class="comment">// When nothing is left to do, just return reversed tuple list.</span>
    <span class="kw">fn</span> <span class="ident">rewind</span>(<span class="self">self</span>, <span class="ident">done</span>: <span class="ident">Done</span>) -&gt; <span class="ident">Done</span> { <span class="ident">done</span> }
}
 
<span class="comment">// Recursion step.</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">Done</span>, <span class="ident">Next</span>, <span class="ident">Tail</span><span class="op">&gt;</span> <span class="ident">Rewind</span><span class="op">&lt;</span><span class="ident">Done</span><span class="op">&gt;</span> <span class="kw">for</span> (<span class="ident">Next</span>, <span class="ident">Tail</span>) <span class="kw">where</span>
    <span class="ident">Done</span>: <span class="ident">TupleList</span>,
    (<span class="ident">Next</span>, <span class="ident">Done</span>): <span class="ident">TupleList</span>,
    <span class="ident">Tail</span>: <span class="ident">Rewind</span><span class="op">&lt;</span>(<span class="ident">Next</span>, <span class="ident">Done</span>)<span class="op">&gt;</span> <span class="op">+</span> <span class="ident">TupleList</span>,
{
    <span class="kw">type</span> <span class="ident">RewindResult</span> <span class="op">=</span> <span class="ident">Tail::RewindResult</span>;
 
    <span class="comment">// Strip head element from `Todo` and prepend it to `Done` list,</span>
    <span class="comment">// then recurse on remaining tail of `Todo`.</span>
    <span class="kw">fn</span> <span class="ident">rewind</span>(<span class="self">self</span>, <span class="ident">done</span>: <span class="ident">Done</span>) -&gt; <span class="ident"><span class="self">Self</span>::RewindResult</span> {
        <span class="kw">let</span> (<span class="ident">next</span>, <span class="ident">tail</span>) <span class="op">=</span> <span class="self">self</span>;
        <span class="kw">return</span> <span class="ident">tail</span>.<span class="ident">rewind</span>((<span class="ident">next</span>, <span class="ident">done</span>));
    }
}
 
<span class="comment">// Helper function which uses `Rewind` trait to reverse a tuple list.</span>
<span class="kw">fn</span> <span class="ident">reverse</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="ident">tuple</span>: <span class="ident">T</span>) -&gt; <span class="ident">T::RewindResult</span> <span class="kw">where</span>
    <span class="ident">T</span>: <span class="ident">Rewind</span><span class="op">&lt;</span>()<span class="op">&gt;</span>
{
    <span class="comment">// Initial condition, whole tuple list is `Todo`,</span>
    <span class="comment">// empty tuple is `Done`.</span>
    <span class="ident">tuple</span>.<span class="ident">rewind</span>(())
}
 
<span class="comment">// Now `reverse` is usable on tuple lists.</span>
<span class="kw">let</span> <span class="ident">original</span> <span class="op">=</span> <span class="macro">tuple_list!</span>(<span class="number">1</span>, <span class="string">&quot;foo&quot;</span>, <span class="bool-val">false</span>);
<span class="kw">let</span> <span class="ident">reversed</span> <span class="op">=</span> <span class="macro">tuple_list!</span>(<span class="bool-val">false</span>, <span class="string">&quot;foo&quot;</span>, <span class="number">1</span>);
 
<span class="macro">assert_eq!</span>(<span class="ident">reverse</span>(<span class="ident">original</span>), <span class="ident">reversed</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Aextern%20crate%20r%23tuple_list%3B%0Afn%20main()%20%7B%0Ause%20tuple_list%3A%3ATupleList%3B%0Ause%20tuple_list%3A%3Atuple_list%3B%0A%2F%2F%20Rewind%20is%20a%20helper%20trait%20which%20maintains%20two%20tuple%20lists%3A%0A%2F%2F%20%60Todo%60%20(which%20is%20%60Self%60%20for%20the%20trait)%20is%20the%20remainder%20of%20a%20tuple%20list%20to%20be%20reversed.%0A%2F%2F%20%60Done%60%20is%20already%20reversed%20part%20of%20it.%0Atrait%20Rewind%3CDone%3A%20TupleList%3E%20%7B%0A%20%20%20%20%2F%2F%20RewindResult%20is%20the%20type%20of%20fully%20reversed%20tuple.%0A%20%20%20%20type%20RewindResult%3A%20TupleList%3B%0A%20%0A%20%20%20%20fn%20rewind(self%2C%20done%3A%20Done)%20-%3E%20Self%3A%3ARewindResult%3B%0A%7D%0A%20%0A%2F%2F%20Initial%20condition.%0Aimpl%3CDone%3A%20TupleList%3E%20Rewind%3CDone%3E%20for%20()%20%7B%0A%20%20%20%20type%20RewindResult%20%3D%20Done%3B%0A%20%0A%20%20%20%20%2F%2F%20When%20nothing%20is%20left%20to%20do%2C%20just%20return%20reversed%20tuple%20list.%0A%20%20%20%20fn%20rewind(self%2C%20done%3A%20Done)%20-%3E%20Done%20%7B%20done%20%7D%0A%7D%0A%20%0A%2F%2F%20Recursion%20step.%0Aimpl%3CDone%2C%20Next%2C%20Tail%3E%20Rewind%3CDone%3E%20for%20(Next%2C%20Tail)%20where%0A%20%20%20%20Done%3A%20TupleList%2C%0A%20%20%20%20(Next%2C%20Done)%3A%20TupleList%2C%0A%20%20%20%20Tail%3A%20Rewind%3C(Next%2C%20Done)%3E%20%2B%20TupleList%2C%0A%7B%0A%20%20%20%20type%20RewindResult%20%3D%20Tail%3A%3ARewindResult%3B%0A%20%0A%20%20%20%20%2F%2F%20Strip%20head%20element%20from%20%60Todo%60%20and%20prepend%20it%20to%20%60Done%60%20list%2C%0A%20%20%20%20%2F%2F%20then%20recurse%20on%20remaining%20tail%20of%20%60Todo%60.%0A%20%20%20%20fn%20rewind(self%2C%20done%3A%20Done)%20-%3E%20Self%3A%3ARewindResult%20%7B%0A%20%20%20%20%20%20%20%20let%20(next%2C%20tail)%20%3D%20self%3B%0A%20%20%20%20%20%20%20%20return%20tail.rewind((next%2C%20done))%3B%0A%20%20%20%20%7D%0A%7D%0A%20%0A%2F%2F%20Helper%20function%20which%20uses%20%60Rewind%60%20trait%20to%20reverse%20a%20tuple%20list.%0Afn%20reverse%3CT%3E(tuple%3A%20T)%20-%3E%20T%3A%3ARewindResult%20where%0A%20%20%20%20T%3A%20Rewind%3C()%3E%0A%7B%0A%20%20%20%20%2F%2F%20Initial%20condition%2C%20whole%20tuple%20list%20is%20%60Todo%60%2C%0A%20%20%20%20%2F%2F%20empty%20tuple%20is%20%60Done%60.%0A%20%20%20%20tuple.rewind(())%0A%7D%0A%20%0A%2F%2F%20Now%20%60reverse%60%20is%20usable%20on%20tuple%20lists.%0Alet%20original%20%3D%20tuple_list!(1%2C%20%22foo%22%2C%20false)%3B%0Alet%20reversed%20%3D%20tuple_list!(false%2C%20%22foo%22%2C%201)%3B%0A%20%0Aassert_eq!(reverse(original)%2C%20reversed)%3B%0A%7D&amp;edition=2018">Run</a></div>
<h2 id="tuple-lists-and-tuples-interoperability"><a href="#tuple-lists-and-tuples-interoperability">Tuple lists and tuples interoperability</a></h2>
<p>This crate defines <code>Tuple</code> and <code>TupleList</code> traits, which
are automatically implemented and allow you to convert
tuples into tuple lists and vice versa.</p>
<p>Best way to handle interoperability is to store your data
as tuple lists and convert them to tuples if necessary.</p>
<p>Alternatively it’s possible to create a helper function
which accepts a tuple, converts it to a tuple list,
calls trait method and then returns the result.</p>
<p>Here’s an example of such function for <code>Append</code>
trait from previous example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// `Tuple` trait is needed to access conversion function.</span>
<span class="kw">use</span> <span class="ident">tuple_list::Tuple</span>;
 
<span class="kw">fn</span> <span class="ident">append</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">AppendedTupleList</span>, <span class="ident">Elem</span><span class="op">&gt;</span>(<span class="ident">tuple</span>: <span class="ident">T</span>, <span class="ident">elem</span>: <span class="ident">Elem</span>) -&gt; <span class="ident">AppendedTupleList::Tuple</span> <span class="kw">where</span>
    <span class="ident">T</span>: <span class="ident">Tuple</span>,                                                   <span class="comment">// input argument tuple</span>
    <span class="ident">T::TupleList</span>: <span class="ident">Append</span><span class="op">&lt;</span><span class="ident">Elem</span>, <span class="ident">AppendResult</span><span class="op">=</span><span class="ident">AppendedTupleList</span><span class="op">&gt;</span>, <span class="comment">// input argument tuple list</span>
    <span class="ident">AppendedTupleList</span>: <span class="ident">TupleList</span>,                               <span class="comment">// resulting tuple list</span>
{
    <span class="comment">// Convert tuple into tuple list, append the element</span>
    <span class="comment">// and convert the result back into tuple.</span>
    <span class="ident">tuple</span>.<span class="ident">into_tuple_list</span>().<span class="ident">append</span>(<span class="ident">elem</span>).<span class="ident">into_tuple</span>()
}
 
<span class="comment">// Unlike `Append` trait which is defined for tuple lists,</span>
<span class="comment">// `append` function works on regular tuples.</span>
<span class="kw">let</span> <span class="ident">original</span> <span class="op">=</span> (<span class="number">1</span>, <span class="string">&quot;foo&quot;</span>, <span class="bool-val">false</span>);
<span class="kw">let</span> <span class="ident">appended</span> <span class="op">=</span> (<span class="number">1</span>, <span class="string">&quot;foo&quot;</span>, <span class="bool-val">false</span>, <span class="number">5</span>);
 
<span class="macro">assert_eq!</span>(<span class="ident">append</span>(<span class="ident">original</span>, <span class="number">5</span>), <span class="ident">appended</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Aextern%20crate%20r%23tuple_list%3B%0Afn%20main()%20%7B%0Ause%20tuple_list%3A%3ATupleList%3B%0Ause%20tuple_list%3A%3Atuple_list%3B%0Atrait%20Append%3CT%3E%3A%20TupleList%20%7B%0A%20%20%20%20type%20AppendResult%3A%20TupleList%3B%0A%20%20%20%20fn%20append(self%2C%20value%3A%20T)%20-%3E%20Self%3A%3AAppendResult%3B%0A%7D%0Aimpl%3CT%3E%20Append%3CT%3E%20for%20()%20%7B%0A%20%20%20%20type%20AppendResult%20%3D%20(T%2C%20())%3B%0A%20%20%20%20fn%20append(self%2C%20value%3A%20T)%20-%3E%20Self%3A%3AAppendResult%20%7B%20(value%2C%20())%20%7D%0A%7D%0Aimpl%3CHead%2C%20Tail%2C%20T%3E%20Append%3CT%3E%20for%20(Head%2C%20Tail)%20where%0A%20%20%20%20Self%3A%20TupleList%2C%0A%20%20%20%20Tail%3A%20Append%3CT%3E%2C%0A%20%20%20%20(Head%2C%20Tail%3A%3AAppendResult)%3A%20TupleList%2C%0A%7B%0A%20%20%20%20type%20AppendResult%20%3D%20(Head%2C%20Tail%3A%3AAppendResult)%3B%0A%20%20%20%20fn%20append(self%2C%20value%3A%20T)%20-%3E%20Self%3A%3AAppendResult%20%7B%0A%20%20%20%20%20%20%20%20let%20(head%2C%20tail)%20%3D%20self%3B%0A%20%20%20%20%20%20%20%20return%20(head%2C%20tail.append(value))%3B%0A%20%20%20%20%7D%0A%7D%0A%2F%2F%20%60Tuple%60%20trait%20is%20needed%20to%20access%20conversion%20function.%0Ause%20tuple_list%3A%3ATuple%3B%0A%20%0Afn%20append%3CT%2C%20AppendedTupleList%2C%20Elem%3E(tuple%3A%20T%2C%20elem%3A%20Elem)%20-%3E%20AppendedTupleList%3A%3ATuple%20where%0A%20%20%20%20T%3A%20Tuple%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20input%20argument%20tuple%0A%20%20%20%20T%3A%3ATupleList%3A%20Append%3CElem%2C%20AppendResult%3DAppendedTupleList%3E%2C%20%2F%2F%20input%20argument%20tuple%20list%0A%20%20%20%20AppendedTupleList%3A%20TupleList%2C%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20resulting%20tuple%20list%0A%7B%0A%20%20%20%20%2F%2F%20Convert%20tuple%20into%20tuple%20list%2C%20append%20the%20element%0A%20%20%20%20%2F%2F%20and%20convert%20the%20result%20back%20into%20tuple.%0A%20%20%20%20tuple.into_tuple_list().append(elem).into_tuple()%0A%7D%0A%20%0A%2F%2F%20Unlike%20%60Append%60%20trait%20which%20is%20defined%20for%20tuple%20lists%2C%0A%2F%2F%20%60append%60%20function%20works%20on%20regular%20tuples.%0Alet%20original%20%3D%20(1%2C%20%22foo%22%2C%20false)%3B%0Alet%20appended%20%3D%20(1%2C%20%22foo%22%2C%20false%2C%205)%3B%0A%20%0Aassert_eq!(append(original%2C%205)%2C%20appended)%3B%0A%7D&amp;edition=2018">Run</a></div>
<p>Please note that tuple/tuple list conversions are
destructive and consume the original, which seemingly
prevents you from, for example, modifying content
of the original tuple.</p>
<p>In order to alleviate this problem, <code>tuple_list</code> crate
introduces <code>AsTupleOfRefs</code> trait, which allows one to
convert reference to tuple into tuple of references.</p>
<p>The idea is that if you you can convert reference to tuple
into tuple of references, then convert tuple of references
into tuple list and then use recursive trait as usual.</p>
<p>Let’s modify <code>PlusOne</code> trait example so it can be used
to modify regular tuples:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Define trait and implement it for several primitive types.</span>
<span class="kw">trait</span> <span class="ident">PlusOne</span> {
    <span class="kw">fn</span> <span class="ident">plus_one</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>);
}
<span class="kw">impl</span> <span class="ident">PlusOne</span> <span class="kw">for</span> <span class="ident">i32</span>    { <span class="kw">fn</span> <span class="ident">plus_one</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>) { <span class="kw-2">*</span><span class="self">self</span> <span class="op">+</span><span class="op">=</span> <span class="number">1</span>; } }
<span class="kw">impl</span> <span class="ident">PlusOne</span> <span class="kw">for</span> <span class="ident">bool</span>   { <span class="kw">fn</span> <span class="ident">plus_one</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>) { <span class="kw-2">*</span><span class="self">self</span> <span class="op">=</span> <span class="op">!</span><span class="kw-2">*</span><span class="self">self</span>; } }
<span class="kw">impl</span> <span class="ident">PlusOne</span> <span class="kw">for</span> <span class="ident">String</span> { <span class="kw">fn</span> <span class="ident">plus_one</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>) { <span class="self">self</span>.<span class="ident">push</span>(<span class="string">&#39;1&#39;</span>); } }
 
<span class="comment">// Now we have to define a new trait</span>
<span class="comment">// specifically for tuple lists of references.</span>
<span class="comment">//</span>
<span class="comment">// Unlike the original, it accepts `self` by value.</span>
<span class="kw">trait</span> <span class="ident">PlusOneTupleList</span>: <span class="ident">TupleList</span> {
    <span class="kw">fn</span> <span class="ident">plus_one</span>(<span class="self">self</span>);
}
 
<span class="comment">// Now we have to implement trait for an empty tuple,</span>
<span class="comment">// thus defining initial condition.</span>
<span class="kw">impl</span> <span class="ident">PlusOneTupleList</span> <span class="kw">for</span> () {
    <span class="kw">fn</span> <span class="ident">plus_one</span>(<span class="self">self</span>) {}
}
 
<span class="comment">// Now we can implement trait for a non-empty tuple list,</span>
<span class="comment">// thus defining recursion and supporting tuple lists of arbitrary length.</span>
<span class="comment">//</span>
<span class="comment">// Note that we&#39;re implementing `PlusOneTupleList` for</span>
<span class="comment">// *tuple list of mutable references*, and as a result</span>
<span class="comment">// head of the list is a mutable reference, not a value.</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">Head</span>, <span class="ident">Tail</span><span class="op">&gt;</span> <span class="ident">PlusOneTupleList</span> <span class="kw">for</span> (<span class="kw-2">&amp;mut</span> <span class="ident">Head</span>, <span class="ident">Tail</span>) <span class="kw">where</span>
    <span class="self">Self</span>: <span class="ident">TupleList</span>,
    <span class="ident">Head</span>: <span class="ident">PlusOne</span>,
    <span class="ident">Tail</span>: <span class="ident">PlusOneTupleList</span>,
{
    <span class="kw">fn</span> <span class="ident">plus_one</span>(<span class="self">self</span>) {
        <span class="self">self</span>.<span class="number">0</span>.<span class="ident">plus_one</span>();
        <span class="self">self</span>.<span class="number">1</span>.<span class="ident">plus_one</span>();
    }
}
 
<span class="comment">// Now let&#39;s define a helper function operating on regular tuples.</span>
<span class="kw">fn</span> <span class="ident">plus_one</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">T</span>, <span class="ident">RT</span><span class="op">&gt;</span>(<span class="ident">tuple</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="kw-2">mut</span> <span class="ident">T</span>) <span class="kw">where</span>
    <span class="ident">T</span>: <span class="ident">AsTupleOfRefs</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">TupleOfMutRefs</span><span class="op">=</span><span class="ident">RT</span><span class="op">&gt;</span>,
    <span class="ident">RT</span>: <span class="ident">Tuple</span> <span class="op">+</span> <span class="lifetime">&#39;a</span>,
    <span class="ident">RT::TupleList</span>: <span class="ident">PlusOneTupleList</span>,
 
{
    <span class="ident">tuple</span>.<span class="ident">as_tuple_of_mut_refs</span>().<span class="ident">into_tuple_list</span>().<span class="ident">plus_one</span>()
}
 
<span class="comment">// Now we can use this helper function on regular tuples.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">tuple</span> <span class="op">=</span> (<span class="number">2</span>, <span class="bool-val">false</span>, <span class="ident">String::from</span>(<span class="string">&quot;abc&quot;</span>));
<span class="ident">plus_one</span>(<span class="kw-2">&amp;mut</span> <span class="ident">tuple</span>);
 
<span class="macro">assert_eq!</span>(<span class="ident">tuple</span>.<span class="number">0</span>, <span class="number">3</span>);
<span class="macro">assert_eq!</span>(<span class="ident">tuple</span>.<span class="number">1</span>, <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span><span class="ident">tuple</span>.<span class="number">2</span>, <span class="string">&quot;abc1&quot;</span>);</code></pre><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Aextern%20crate%20r%23tuple_list%3B%0Afn%20main()%20%7B%0Ause%20tuple_list%3A%3ATupleList%3B%0Ause%20tuple_list%3A%3ATuple%3B%0Ause%20tuple_list%3A%3AAsTupleOfRefs%3B%0A%2F%2F%20Define%20trait%20and%20implement%20it%20for%20several%20primitive%20types.%0Atrait%20PlusOne%20%7B%0A%20%20%20%20fn%20plus_one(%26mut%20self)%3B%0A%7D%0Aimpl%20PlusOne%20for%20i32%20%20%20%20%7B%20fn%20plus_one(%26mut%20self)%20%7B%20*self%20%2B%3D%201%3B%20%7D%20%7D%0Aimpl%20PlusOne%20for%20bool%20%20%20%7B%20fn%20plus_one(%26mut%20self)%20%7B%20*self%20%3D%20!*self%3B%20%7D%20%7D%0Aimpl%20PlusOne%20for%20String%20%7B%20fn%20plus_one(%26mut%20self)%20%7B%20self.push('1')%3B%20%7D%20%7D%0A%20%0A%2F%2F%20Now%20we%20have%20to%20define%20a%20new%20trait%0A%2F%2F%20specifically%20for%20tuple%20lists%20of%20references.%0A%2F%2F%0A%2F%2F%20Unlike%20the%20original%2C%20it%20accepts%20%60self%60%20by%20value.%0Atrait%20PlusOneTupleList%3A%20TupleList%20%7B%0A%20%20%20%20fn%20plus_one(self)%3B%0A%7D%0A%20%0A%2F%2F%20Now%20we%20have%20to%20implement%20trait%20for%20an%20empty%20tuple%2C%0A%2F%2F%20thus%20defining%20initial%20condition.%0Aimpl%20PlusOneTupleList%20for%20()%20%7B%0A%20%20%20%20fn%20plus_one(self)%20%7B%7D%0A%7D%0A%20%0A%2F%2F%20Now%20we%20can%20implement%20trait%20for%20a%20non-empty%20tuple%20list%2C%0A%2F%2F%20thus%20defining%20recursion%20and%20supporting%20tuple%20lists%20of%20arbitrary%20length.%0A%2F%2F%0A%2F%2F%20Note%20that%20we're%20implementing%20%60PlusOneTupleList%60%20for%0A%2F%2F%20*tuple%20list%20of%20mutable%20references*%2C%20and%20as%20a%20result%0A%2F%2F%20head%20of%20the%20list%20is%20a%20mutable%20reference%2C%20not%20a%20value.%0Aimpl%3CHead%2C%20Tail%3E%20PlusOneTupleList%20for%20(%26mut%20Head%2C%20Tail)%20where%0A%20%20%20%20Self%3A%20TupleList%2C%0A%20%20%20%20Head%3A%20PlusOne%2C%0A%20%20%20%20Tail%3A%20PlusOneTupleList%2C%0A%7B%0A%20%20%20%20fn%20plus_one(self)%20%7B%0A%20%20%20%20%20%20%20%20self.0.plus_one()%3B%0A%20%20%20%20%20%20%20%20self.1.plus_one()%3B%0A%20%20%20%20%7D%0A%7D%0A%20%0A%2F%2F%20Now%20let's%20define%20a%20helper%20function%20operating%20on%20regular%20tuples.%0Afn%20plus_one%3C'a%2C%20T%2C%20RT%3E(tuple%3A%20%26'a%20mut%20T)%20where%0A%20%20%20%20T%3A%20AsTupleOfRefs%3C'a%2C%20TupleOfMutRefs%3DRT%3E%2C%0A%20%20%20%20RT%3A%20Tuple%20%2B%20'a%2C%0A%20%20%20%20RT%3A%3ATupleList%3A%20PlusOneTupleList%2C%0A%20%0A%7B%0A%20%20%20%20tuple.as_tuple_of_mut_refs().into_tuple_list().plus_one()%0A%7D%0A%20%0A%2F%2F%20Now%20we%20can%20use%20this%20helper%20function%20on%20regular%20tuples.%0Alet%20mut%20tuple%20%3D%20(2%2C%20false%2C%20String%3A%3Afrom(%22abc%22))%3B%0Aplus_one(%26mut%20tuple)%3B%0A%20%0Aassert_eq!(tuple.0%2C%203)%3B%0Aassert_eq!(tuple.1%2C%20true)%3B%0Aassert_eq!(%26tuple.2%2C%20%22abc1%22)%3B%0A%7D&amp;edition=2018">Run</a></div>
<p>As you can see, working with tuples requires a lot
of bolierplate code. Unless you have preexisting code
you need to support, it’s generally better to use
tuple lists directly, since they are much easier
to work with.</p>
<h2 id="implementing-recursive-traits-for-regular-tuples"><a href="#implementing-recursive-traits-for-regular-tuples">Implementing recursive traits for regular tuples</a></h2>
<p>Implementing recursive traits for regular tuples poses
certain problems. As of now it is possible within
<code>tuple_list</code> crate, but quickly leads to orphan rules
violations when used outside of it.</p>
<p>You can see a working example of a trait implemented for
regular tuples in <code>tuple_list::test::all_features</code>,
but it’s overly complex and pretty much experimental.</p>
<p>It should be possible to define recursive traits on regular tuples
once trait specialization feature is implemented in Rust.</p>
</div></details><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.tuple_list.html" title="tuple_list::tuple_list macro">tuple_list</a></div><div class="item-right docblock-short"><p>Macro creating tuple list values from list of expressions.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.tuple_list_type.html" title="tuple_list::tuple_list_type macro">tuple_list_type</a></div><div class="item-right docblock-short"><p>Macro creating tuple list types from list of element types.</p>
</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.AsTupleOfRefs.html" title="tuple_list::AsTupleOfRefs trait">AsTupleOfRefs</a></div><div class="item-right docblock-short"><p>Trait providing conversion from references to tuples into tuples of references.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.NonEmptyTuple.html" title="tuple_list::NonEmptyTuple trait">NonEmptyTuple</a></div><div class="item-right docblock-short"><p>Trait allowing to recursively deconstruct tuples.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Tuple.html" title="tuple_list::Tuple trait">Tuple</a></div><div class="item-right docblock-short"><p>Trait providing conversion from tuple into tuple list.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.TupleCons.html" title="tuple_list::TupleCons trait">TupleCons</a></div><div class="item-right docblock-short"><p>Trait providing tuple construction function, allows to prepend a value to a tuple.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.TupleList.html" title="tuple_list::TupleList trait">TupleList</a></div><div class="item-right docblock-short"><p>Trait providing conversion from tuple list into tuple.</p>
</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="tuple_list" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.64.0-nightly (2643b1646 2022-07-27)" ></div>
</body></html>